'.source.cpp':
  'bellman_ford':
    'prefix': 'bellman_ford'
    'body':'''
        const int MAX_E = ${1:100000};
        const int MAX_V = ${2:100000};

        struct edge{int from, to; ll cost;};
        edge es[MAX_E];

        ll d[MAX_V];
        int V, E;

        bool bellman_ford(int s){
          REP(i,V)d[i] = INFll;
          d[s] = 0;
          REP(i,V){
            bool update = false;
            REP(j,E){
              edge e = es[j];
              if(d[e.from] != INFll && d[e.to] > d[e.from] + e.cost){
                d[e.to] = d[e.from] + e.cost;
                update = true;
                if(i == V-1){
                  return false;
                }
              }
            }
            if(!update) break;
          }
          return true;
        }
      '''
  'dijkstra':
    'prefix':'dijkstra'
    'body':'''
        // set V in main
        // d[MAX_V] shows the answer
        
        const int MAX_V = ${1:100000};

        struct edge{int to; ll cost;};
        typedef pair<ll, int> P;

        int V;
        vector<edge> G[MAX_V];
        ll d[MAX_V];

        void dijkstra(int s){
          priority_queue<P, vector<P>, greater<P>  > que;
          fill(d, d + V, INFll);
          d[s] = 0;
          que.push(P(0,s));

          while(!que.empty()){
            P p = que.top(); que.pop();
            int v = p.second;
            if(d[v] < p.first) continue;
            for(int i = 0; i < G[v].size(); i++){
              edge e = G[v][i];
              if(d[e.to] > d[v] + e.cost){
                d[e.to] = d[v] + e.cost;
                que.push(P(d[e.to], e.to));
              }
            }
          }
        }
      '''
  'gcd':
    'prefix':'gcd'
    'body':'''
      ll gcd(ll x, ll y){
        if(x == 0)return y;
        return gcd(y%x, x);
      }
      '''
  'mod_comb':
    'prefix':'mod_comb'
    'body':'''
      // mod_comb(n, k, p) → nCk p:MOD // O(p) + O(n log p)

      const ll MAX_P = ${1:100000};
      ll fact[MAX_P];

      void fact_init(ll p){
        fact[0] = 1;
        REP(i,p-1)fact[i+1] = fact[i] + (i+1) % p;
      }

      ll extgcd(ll a, ll b, ll& x, ll& y){
        ll d = a;
        if(b!=0){
          d = extgcd(b, a%b, y, x);
          y -= (a / b) * x;
        }else{
          x = 1; y = 0;
        }
        return d;
      }

      ll mod_inverse(ll a, ll m){
        ll x, y;
        extgcd(a, m, x, y);
        return (m + x % m) % m;
      }

      ll mod_fact(ll n, ll p, ll& e){
        e = 0;
        if(n==0)return 1;
        ll res = mod_fact(n/p, p, e);
        e += n/p;
        if(n/p%2 != 0) return res * (p - fact[n % p]) % p;
        return res * fact[n % p] % p;
      }

      ll mod_comb(int n, int k, int p){
        if(n < 0 || k < 0 || n < k)return 0;
        ll e1, e2, e3;
        ll a1 = mod_fact(n,p,e1), a2 = mod_fact(k, p, e2), a3 = mod_fact(n-k, p, e3);
        if(e1 > e2 + e3) return 0;
        return a1 * mod_inverse(a2 * a3 % p, p) % p;
      }
      '''
  'nck':
    'prefix':'nck'
    'body':'''
      // pascal's triangle // C[n][k] -> nCk //　O(n^2)
      const int MAX_N = ${1:10000};
      ll C[MAX_N][MAX_N];
      void comb_table(int n){
        REP(i,n+1){
          REP(j,i+1){
            if(j==0 || j==i){
              C[i][j]=1LL;
            }else{
              C[i][j]=(C[i-1][j-1]+C[i-1][j]);
            }
          }
        }
      }
      '''
